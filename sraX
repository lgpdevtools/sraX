#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use FindBin;
use lib "$FindBin::RealBin";
use Cwd qw(getcwd);
use sraXlib::Functions;
use sraXlib::Dir;
use sraXlib::DB;
use sraXlib::Blast;
use sraXlib::Parse;
use sraXlib::SNP;

my $home_dir    = getcwd();
my $d_gnm	= "";
my $d_out	= "";
my $f_log	= "";
my $usr_db	= "";
my $bprog	= "";
my $eval	= "";
my $idty	= "";
my $cvrg	= "";
my $thrd	= "";
my $version;
my $verbose;
my $help;

my $cmmnd_l = GetOptions('genome_directory|d=s' 	=> \$d_gnm,
			 'output|o=s' 			=> \$d_out,
			 'blast_x|p=s'       		=> \$bprog,
                         'eval|e=f'             	=> \$eval, 
                         'id|i=f'        		=> \$idty, 
                         'aln_cov|c=f'          	=> \$cvrg, 
			 'user_sq|u=s' 			=> \$usr_db,
			 'threads|t=i' 			=> \$thrd,  
			 'version|v' 			=> \$version,
			 'verbose|ver'			=> \$verbose,				
			 'help|h' 			=> \$help,
                        );


unless ($cmmnd_l){
    die "Please, check the command line options and their possible values.\n";
}

if ($help){
    help_descr();
    exit;
}

if($version){
    print << "VERSION";

           sraX - Systematic Resistome Analysis 

                                version: sraXv1

             Copyright 2019 Leonardo G. Panunzi
VERSION

exit(0);
}

my $t_start_time_cp = sraXlib::Functions::running_time;
my $d_gnm_abs   = "$home_dir/$d_gnm";
my $d_out_abs   = "$home_dir/$d_out";

if($d_gnm eq ''){
print STDERR "\nFor running the 'sraX' tool, it's mandatory to provide, at least, a directory containing the genome(s) that you want to analyze.\n";
print STDERR "Suspending the execution of 'sraX' and quitting now!\n";
help_descr();
exit(0);
}else{
	my $d_pres = sraXlib::Functions::check_dir($d_gnm_abs);
	unless($d_pres == 1){
        print STDERR "\n[Error]: The given directory '$d_gnm' is not present\n";
        print STDERR "Please, check its absolute path, existence or given name.\n";
        print STDERR "Suspending the execution of sraX and quitting now!\n";
        exit(0);
        }else{
        my $d_start_time_cp = sraXlib::Functions::print_time;
        print "\nThe 'sraX' analysis started at:\t$d_start_time_cp\n\n";
	$f_log = "The 'sraX' analysis started at:\t$d_start_time_cp\n\n";
        }
}

if($bprog eq ''){
$bprog = 'dblastx';
$f_log .= sraXlib::Functions::print_ne('p',$bprog);
}elsif($bprog ne 'dblastx' && $bprog ne 'dblastp' && $bprog ne 'blastx' && $bprog ne 'blastp' && $bprog ne 'blastn'){
$f_log .= (sraXlib::Functions::print_e('p',$bprog) && exit(0));
}else{
}

if($eval eq ''){
$eval = 1e-05;
$f_log .= sraXlib::Functions::print_ne('e',$eval);
}elsif($eval < 0){
$f_log .= (sraXlib::Functions::print_e('e',$eval) && exit(0));
}else{
}       

if($idty eq ''){
$idty = 85;
$f_log .= sraXlib::Functions::print_ne('i',$idty);
}elsif($idty <= 0 || $idty > 100){
$f_log .= (sraXlib::Functions::print_e('i',$idty) && exit(0));
}else{
}

if($cvrg eq ''){
$cvrg = 60;
$f_log .= sraXlib::Functions::print_ne('c',$cvrg);
}elsif($cvrg <= 0 || $cvrg > 100){
$f_log .= (sraXlib::Functions::print_e('c',$cvrg) && exit(0));
}else{
}       

if($thrd eq ''){
$thrd = 6;
$f_log .= sraXlib::Functions::print_ne('t',$thrd);
}elsif($thrd < 1 || $thrd > 12){
$f_log .= (sraXlib::Functions::print_e('t',$thrd) && exit(0));
}else{
}       

if($d_out eq ''){
$d_out   = $d_gnm."_sraX_".$idty."_".$cvrg."_".$bprog;
$d_out_abs = "$home_dir/$d_out";
$f_log .= sraXlib::Functions::print_ne('n',$d_out);
	my $d_pres = sraXlib::Functions::check_dir($d_out_abs);
        unless($d_pres == 1){
        print STDERR "\nThe results will be placed in the following directory: '$d_out'.\n";
        $f_log .= "\nThe results will be placed in the following directory: '$d_out'.\n";
	}else{
        print STDERR "\n[Warn]: The directory '$d_out' is already present, implying that the script has already been run.\n";
        print STDERR "[Warn]: This directory and all previous results are going to be overwritten now.\n";
	$f_log .= "\n[Warn]: The directory '$d_out' is already present, implying that the script has already been run.\n";
	$f_log .= "[Warn]: This directory and all previous results are going to be overwritten now.\n";
        system("rm -r $d_out_abs");
        }
}else{
        
	my $d_pres = sraXlib::Functions::check_dir($d_out_abs);
        unless($d_pres == 1){
        print STDERR "\nThe results will be placed in the following directory: '$d_out'.\n";
        $f_log .= "\nThe results will be placed in the following directory: '$d_out'.\n";
	}else{
        print STDERR "\n[Warn]: The directory '$d_out' is already present, implying that the script has already been run.\n";
        print STDERR "[Warn]: This directory and all previous results are going to be overwritten now.\n";
	$f_log .= "\n[Warn]: The directory '$d_out' is already present, implying that the script has already been run.\n";
	$f_log .= "[Warn]: This directory and all previous results are going to be overwritten now.\n";
        system("rm -r $d_out");
        }
}

sraXlib::Dir::build_dir_str($d_out_abs);

unless($usr_db eq ''){
sraXlib::DB::get_publ_db($d_out_abs,"usq");
sraXlib::DB::get_user_db($d_out_abs,$usr_db);
}else{
sraXlib::DB::get_publ_db($d_out_abs,"nsq");
}

$f_log .= sraXlib::Blast::set_prmt($d_gnm_abs,$d_out_abs,$bprog,$eval,$idty,$cvrg,$thrd);
sraXlib::Parse::f_parse($d_gnm_abs,$d_out_abs,$idty,$cvrg);
sraXlib::SNP::sq_variants($d_out_abs);

my $t_stop_time_cp = sraXlib::Functions::running_time;
my $d_stop_time_cp = sraXlib::Functions::print_time;
print "\n\tThe completion of 'sraX' analysis took ";
printf("%.2f ", $t_stop_time_cp - $t_start_time_cp);
print " wallclock secs\n\n";
open	LOG, ">$d_out_abs/Log/sraX_log.txt" or die "Can't open 'log file': $!";
print	LOG "$f_log\n";
print	LOG "\n\tThe completion of 'sraX' analysis took ";
printf	LOG ("%.2f ", $t_stop_time_cp - $t_start_time_cp);
print	LOG " wallclock secs\n\n";
close	LOG;

sub help_descr{
  print <<EOF

  SYNOPSIS:

sraX is designed to read assembled sequence files in FASTA format and systematically detect the presence of
antimicrobial resistance genes (ARGs). The complete analysis relies on the following bioinformatic
dependendences: CARD database (ARG repository), MUSCLE (alignment step for SNP detection) and R environment
(visualization plots).

sraX operates in four main stages:

  I) Sequence data acquisition: The CARD database is downloaded, while its metadata is further parsed
     for compiling a local antimicrobial resistance database (AMR DB).

 II) Sequence homology search: dblastx (DIAMOND blastx) or blastx (NCBI blastx) algorithms are employed
     for querying the genomes against the previously compiled AMR DB.

III) SNP analysis: Reference (from AMR DB) and corresponding homolog (from assembled genomes) sequences are
     gathered into multiple-sequence alignments (MSA) for identifying the SNP positions.     

 IV) Output summary files and visualization: The R software is employed for producing specific plots that
     complement the resulting summary tables, which on the whole are visualized in HTML format files.


  USAGE:      sraX  [options] --genome_dir / -d [input file(s)]


--genome_directory	Mandatory directory containing the input file(s), which must be in FASTA format and
			consisting of individual assembled genome sequences.

--output		Output folder. If not provided, the following default name will be taken:
			
			'genome_directory'_'sraX'_'id'_'aln_cov'_'blast_x'

			Example: input folder = 'Test'; id = 85; aln_cov = 95; blast_x = dblastx
			
			Output folder = 'Test_sraX_85_95_dblastx'

--blast_x		The translated alignments of assembled genome(s) are queried using dblastx
			(DIAMOND blastx) or blastx (NCBI blastx). In any case, the process is parallelized
			(up to 100 genome files are run simultaneously) for reducing computing times
			(default: dblastx)

--eval			Use this evalue cut-off to filter false positives (default: 1e-05)

--id			Use this percent identity cut-off to filter false positives (default: 85)			

--aln_cov		This fraction of the query must align to the reference sequence (default: 60)

--threads		Use this number of threads when running sraX (default: 6)

--help			Displays this help information and exits.

--version		Displays version information and exits.

--verbose		Verbose output (for debugging).

                                   Script last modified: 01 December 2018
EOF
    ;
  exit 1;
}
